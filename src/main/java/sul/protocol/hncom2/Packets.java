/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 */
package sul.protocol.hncom2;

import java.util.Collections;
import java.util.Map;
import java.util.HashMap;

import sul.utils.Packet;

/**
 * Protocol used for the communication between an hub and multiple nodes with support
 * for Minecraft and Minecraft: Pocket Edition and different versions of their protocols.
 * 
 * <h2>Definitions</h2>
 * 
 * <h3>Hub</h3>
 * The hub (server) is the network part of the game server and handles pings, login
 * sequences, keep alive packets, queries, external consoles and everything else that
 * is not related to the gameplay.
 * A server can work with only an hub (nodeless) but every player that will try to
 * join the server will be disconnected because the server is full after the login
 * process.
 * 
 * <h3>Node</h3>
 * The node (client) is the gameplay part of the game server. It contains worlds and
 * entities and has only one network connection, with the hub.
 * 
 * <h2>Connection</h2>
 * 
 * Hncom uses a packet-oriented TCP connection and every packet is prefixed with a
 * little-endian unsigned 32-bits integer, without any exception.
 * 
 * <h3>Authentication</h3>
 * The node starts the connection sending a ConnectionRequest packet with its credentials
 * and waits for a ConnectionResponse packet.
 */
public final class Packets {

	private Packets() {}

	/**
	 * Packets used for sending more than one packet at once.
	 */
	public static final Map<Integer, Class<? extends Packet>> UTIL;

	/**
	 * Packets used during the authentication process to exchange informations.
	 */
	public static final Map<Integer, Class<? extends Packet>> LOGIN;

	/**
	 * Node-related packets and updates.
	 */
	public static final Map<Integer, Class<? extends Packet>> STATUS;

	/**
	 * Packets related to a player. The first field of every packet is an `hub id` that
	 * uniquely identifies a player in the hub and never changes until it's disconnected.
	 */
	public static final Map<Integer, Class<? extends Packet>> PLAYER;

	public static final Map<Integer, Class<? extends Packet>> WORLD;

	public static final Map<Integer, Class<? extends Packet>> PANEL;

	static {

		HashMap<Integer, Class<? extends Packet>> util = new HashMap<Integer, Class<? extends Packet>>();
		util.put(1, sul.protocol.hncom2.util.Uncompressed.class);
		util.put(2, sul.protocol.hncom2.util.Compressed.class);
		UTIL = Collections.unmodifiableMap(util);

		HashMap<Integer, Class<? extends Packet>> login = new HashMap<Integer, Class<? extends Packet>>();
		login.put(3, sul.protocol.hncom2.login.ConnectionRequest.class);
		login.put(4, sul.protocol.hncom2.login.ConnectionResponse.class);
		login.put(5, sul.protocol.hncom2.login.HubInfo.class);
		login.put(6, sul.protocol.hncom2.login.NodeInfo.class);
		LOGIN = Collections.unmodifiableMap(login);

		HashMap<Integer, Class<? extends Packet>> status = new HashMap<Integer, Class<? extends Packet>>();
		status.put(7, sul.protocol.hncom2.status.AddNode.class);
		status.put(8, sul.protocol.hncom2.status.RemoveNode.class);
		status.put(9, sul.protocol.hncom2.status.MessageServerbound.class);
		status.put(10, sul.protocol.hncom2.status.MessageClientbound.class);
		status.put(11, sul.protocol.hncom2.status.Players.class);
		status.put(12, sul.protocol.hncom2.status.ResourcesUsage.class);
		status.put(13, sul.protocol.hncom2.status.Log.class);
		status.put(14, sul.protocol.hncom2.status.RemoteCommand.class);
		status.put(15, sul.protocol.hncom2.status.UpdateList.class);
		status.put(16, sul.protocol.hncom2.status.Reload.class);
		STATUS = Collections.unmodifiableMap(status);

		HashMap<Integer, Class<? extends Packet>> player = new HashMap<Integer, Class<? extends Packet>>();
		player.put(17, sul.protocol.hncom2.player.Add.class);
		player.put(18, sul.protocol.hncom2.player.Remove.class);
		player.put(19, sul.protocol.hncom2.player.Kick.class);
		player.put(20, sul.protocol.hncom2.player.Transfer.class);
		player.put(21, sul.protocol.hncom2.player.UpdateDisplayName.class);
		player.put(22, sul.protocol.hncom2.player.UpdateWorld.class);
		player.put(23, sul.protocol.hncom2.player.UpdateViewDistance.class);
		player.put(24, sul.protocol.hncom2.player.UpdateLanguage.class);
		player.put(25, sul.protocol.hncom2.player.UpdateGamemode.class);
		player.put(26, sul.protocol.hncom2.player.UpdateInputMode.class);
		player.put(27, sul.protocol.hncom2.player.UpdateLatency.class);
		player.put(28, sul.protocol.hncom2.player.UpdatePacketLoss.class);
		player.put(29, sul.protocol.hncom2.player.GamePacket.class);
		player.put(30, sul.protocol.hncom2.player.OrderedGamePacket.class);
		PLAYER = Collections.unmodifiableMap(player);

		HashMap<Integer, Class<? extends Packet>> world = new HashMap<Integer, Class<? extends Packet>>();
		world.put(31, sul.protocol.hncom2.world.Add.class);
		world.put(32, sul.protocol.hncom2.world.Remove.class);
		world.put(33, sul.protocol.hncom2.world.UpdateDifficulty.class);
		world.put(34, sul.protocol.hncom2.world.UpdateGamemode.class);
		world.put(35, sul.protocol.hncom2.world.RequestCreation.class);
		WORLD = Collections.unmodifiableMap(world);

		HashMap<Integer, Class<? extends Packet>> panel = new HashMap<Integer, Class<? extends Packet>>();
		panel.put(36, sul.protocol.hncom2.panel.Connection.class);
		PANEL = Collections.unmodifiableMap(panel);

	}

}
